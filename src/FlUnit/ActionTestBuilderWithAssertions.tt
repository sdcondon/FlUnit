<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ include file="_Common.t4" #>
using FlUnit.Configuration;
using System;
using System.Collections.Generic;
using System.Linq;
#if NET6_0_OR_GREATER
using System.Runtime.CompilerServices;
#else
using System.Linq.Expressions;
#endif
using System.Threading.Tasks;

namespace FlUnit
{
<# for(int i = 0; i <= MaxPrerequisiteCount; i++) { #>
<# WriteLineIf(i > 0); #>
    /// <summary>
    /// Builder for providing additional assertions for a test with a <#= i #> "Given" clause<#= Plural(i) #>
    /// and for which the "When" clause does not return a value.
    /// </summary>
<# WriteTypeParamDocs(i, i => $"The type of the { Ordinal(i) } \"Given\" clause of the test."); #>
    public sealed class ActionTestBuilderWithAssertions<#= TList(i, "<", ">") #>
    {
        private readonly IEnumerable<Action<ITestConfiguration>> configurationOverrides;
#if NET6_0_OR_GREATER
<# WriteLineIf(i > 0, $"private readonly {ArrangeFieldType_ValueTask(i)} arrange;", 2); #>
        private readonly Func<<#= TList(i, "", ", ") #>ValueTask> testAction;
#else
<# WriteLineIf(i > 0, $"private readonly {ArrangeFieldType_Task(i)} arrange;", 2); #>
        private readonly Func<<#= TList(i, "", ", ") #>Task> testAction;
#endif
        private readonly List<AssertionImpl> assertions = new List<AssertionImpl>();

        internal ActionTestBuilderWithAssertions(
            IEnumerable<Action<ITestConfiguration>> configurationOverrides,
#if NET6_0_OR_GREATER
<# WriteLineIf(i > 0, $"{ArrangeFieldType_ValueTask(i)} arrange,", 3); #>
            Func<<#= TList(i, "", ", ") #>ValueTask> testAction,
#else
<# WriteLineIf(i > 0, $"{ArrangeFieldType_Task(i)} arrange,", 3); #>
            Func<<#= TList(i, "", ", ") #>Task> testAction,
#endif
            AssertionImpl assertion)
        {
            this.configurationOverrides = configurationOverrides;
<# WriteLineIf(i > 0, $"this.arrange = arrange;", 3); #>
            this.testAction = testAction;
            assertions.Add(assertion);
        }

        /// <summary>
        /// Implicitly converts a <see cref="ActionTestBuilderWithAssertions<#= TList(i, "{", "}") #>"/> to a <see cref="Test"/> (by building it).
        /// </summary>
        /// <param name="builder">The builder to convert.</param>
        public static implicit operator Test(ActionTestBuilderWithAssertions<#= TList(i, "<", ">") #> builder)
        {
            return new ActionTest<#= TList(i, "<", ">") #>(
                builder.configurationOverrides,
<# WriteLineIf(i > 0, $"builder.arrange,", 4); #>
                builder.testAction,
                tc => builder.assertions.Select(a => new ActionTest<#= TList(i, "<", ">") #>.Assertion(tc, a.Invoke, a.Description)));
        }

#if NET6_0_OR_GREATER
        /// <summary>
        /// Adds an additional assertion for the test.
        /// </summary>
        /// <param name="assertion">The assertion.</param>
        /// <param name="description">The description of the assertion. Optional.</param>
        /// <param name="assertionExpression">
        /// Automatically populated by the compiler - takes the value of the argument expression passed to the assertion parameter.
        /// Used as the description of the assertion if no description is provided - after a little processing (namely, lambda expressions are trimmed so that only their body remains).
        /// </param>
        /// <returns>A builder for providing additional assertions for the test.</returns>
        public ActionTestBuilderWithAssertions<#= TList(i, "<", ">") #> And(
            Action<<#= TList(i, "", ", ") #>TestActionOutcome> assertion,
            string description = null,
            [CallerArgumentExpression("assertion")] string assertionExpression = null)
        {
            assertions.Add(new AssertionImpl(assertion.ToAsyncWrapper(), description ?? AssertionExpressionHelpers.ToAssertionDescription(assertionExpression)));
            return this;
        }

        /// <summary>
        /// Adds an additional assertion for the test.
        /// </summary>
        /// <param name="asyncAssertion">The assertion.</param>
        /// <param name="description">The description of the assertion. Optional.</param>
        /// <param name="assertionExpression">
        /// Automatically populated by the compiler - takes the value of the argument expression passed to the assertion parameter.
        /// Used as the description of the assertion if no description is provided - after a little processing (namely, lambda expressions are trimmed so that only their body remains).
        /// </param>
        /// <returns>A builder for providing additional assertions for the test.</returns>
        public ActionTestBuilderWithAssertions<#= TList(i, "<", ">") #> AndAsync(
            Func<<#= TList(i, "", ", ") #>TestActionOutcome, Task> asyncAssertion,
            string description = null,
            [CallerArgumentExpression("asyncAssertion")] string assertionExpression = null)
        {
            assertions.Add(new AssertionImpl(asyncAssertion.ToAsyncWrapper(), description ?? AssertionExpressionHelpers.ToAssertionDescription(assertionExpression)));
            return this;
        }
#else
        /// <summary>
        /// Adds an additional assertion for the test.
        /// </summary>
        /// <param name="assertion">The assertion.</param>
        /// <returns>A builder for providing additional assertions for the test.</returns>
        public ActionTestBuilderWithAssertions<#= TList(i, "<", ">") #> And(Expression<Action<<#= TList(i, "", ", ") #>TestActionOutcome>> assertion)
        {
            assertions.Add(new AssertionImpl(assertion));
            return this;
        }

        /// <summary>
        /// Adds an additional assertion for the test.
        /// </summary>
        /// <param name="assertion">The assertion.</param>
        /// <param name="description">The description of the assertion.</param>
        /// <returns>A builder for providing additional assertions for the test.</returns>
        public ActionTestBuilderWithAssertions<#= TList(i, "<", ">") #> And(Action<<#= TList(i, "", ", ") #>TestActionOutcome> assertion, string description)
        {
            assertions.Add(new AssertionImpl(assertion.ToAsyncWrapper(), description));
            return this;
        }

        /// <summary>
        /// Adds an additional assertion for the test.
        /// </summary>
        /// <param name="asyncAssertion">The assertion.</param>
        /// <param name="description">The description of the assertion.</param>
        /// <returns>A builder for providing additional assertions for the test.</returns>
        public ActionTestBuilderWithAssertions<#= TList(i, "<", ">") #> AndAsync(Func<<#= TList(i, "", ", ") #>TestActionOutcome, Task> asyncAssertion, string description)
        {
            assertions.Add(new AssertionImpl(asyncAssertion.ToAsyncWrapper(), description));
            return this;
        }
#endif

        internal class AssertionImpl
        {
#if NET6_0_OR_GREATER
            private readonly Func<<#= TList(i, "", ", ") #>TestActionOutcome, ValueTask> assert;

            internal AssertionImpl(Func<<#= TList(i, "", ", ") #>TestActionOutcome, ValueTask> assert, string description)
            {
                this.assert = assert;
                Description = description;
            }
#else
            private readonly Func<<#= TList(i, "", ", ") #>TestActionOutcome, Task> assert;

            internal AssertionImpl(Func<<#= TList(i, "", ", ") #>TestActionOutcome, Task> assert, string description)
            {
                this.assert = assert;
                Description = description;
            }

            internal AssertionImpl(Expression<Action<<#= TList(i, "", ", ") #>TestActionOutcome>> expression)
            {
                assert = expression.Compile().ToAsyncWrapper();
                Description = expression.Body.ToString();
            }
#endif

            public string Description { get; }

#if NET6_0_OR_GREATER
            internal ValueTask Invoke(<#= List(i, i => $"T{i} a{i}", "", ", ") #>TestActionOutcome outcome) => assert(<#= List(i, i => $"a{i}", "", ", ") #>outcome);
#else
            internal Task Invoke(<#= List(i, i => $"T{i} a{i}", "", ", ") #>TestActionOutcome outcome) => assert(<#= List(i, i => $"a{i}", "", ", ") #>outcome);
#endif
        }
    }
<# } #>
}
