<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ include file="_Common.t4" #>
using System;
using System.Collections.Generic;
using System.Linq.Expressions;

namespace FlUnit
{
    /// <summary>
    /// Builder for providing the additional assertions for a test with no "Given" clauses
    /// and for which the "When" clause returns a value.
    /// </summary>
    /// <typeparam name="TResult">The return type of the "When" clause of the test.</typeparam>
    public sealed class TestBuilderWithFunctionAndAssertions<TResult>
    {
        private readonly Func<TResult> testFunction;
        private readonly List<Assertion> assertions = new List<Assertion>();

        internal TestBuilderWithFunctionAndAssertions(Func<TResult> testFunction, Assertion assertion)
        {
            this.testFunction = testFunction;
            assertions.Add(assertion);
        }

        public static implicit operator Test(TestBuilderWithFunctionAndAssertions<TResult> builder)
        {
            return new TestFunction<TResult>(builder.testFunction, builder.assertions);
        }

        /// <summary>
        /// Adds an additional assertion for the test.
        /// </summary>
        /// <param name="assertion">The assertion.</param>
        /// <returns>A builder for providing additional assertions for the test.</returns>
        public TestBuilderWithFunctionAndAssertions<TResult> And(Expression<Action<TestFunctionResult<TResult>>> assertion)
        {
            assertions.Add(new Assertion(assertion));
            return this;
        }

        /// <summary>
        /// Adds an additional assertion for the test.
        /// </summary>
        /// <param name="assertion">The assertion.</param>
        /// <param name="description">The description of the assertion.</param>
        /// <returns>A builder for providing additional assertions for the test.</returns>
        public TestBuilderWithFunctionAndAssertions<TResult> And(Action<TestFunctionResult<TResult>> assertion, string description)
        {
            assertions.Add(new Assertion(assertion, description));
            return this;
        }

        internal class Assertion
        {
            internal Assertion(Action<TestFunctionResult<TResult>> action, string description)
            {
                Action = action;
                Description = description;
            }

            internal Assertion(Expression<Action<TestFunctionResult<TResult>>> expression)
            {
                Action = expression.Compile();
                Description = expression.Body.ToString();
            }

            public Action<TestFunctionResult<TResult>> Action { get; }

            public string Description { get; }
        }
    }

<# for(int i = 1; i <= MaxPrerequisiteCount; i++) { #>
    /// <summary>
    /// Builder for providing the additional assertions for a test with <#= i #> "Given" clauses
    /// and for which the "When" clause returns a value.
    /// </summary>
    <#= TypeParamDocs(i, i => $"The type of the { Ordinal(i) } \"Given\" clause of the test.") #>
    /// <typeparam name="TResult">The return type of the "When" clause of the test.</typeparam>
    public sealed class TestBuilderWithFunctionAndAssertions<<#= TypeParamList(i) #>, TResult>
    {
        private readonly <#= ArrangeFieldType(i) #> arrange;
        private readonly Func<<#= TypeParamList(i) #>, TResult> testFunction;
        private readonly List<Assertion> assertions = new List<Assertion>();

        internal TestBuilderWithFunctionAndAssertions(<#= ArrangeFieldType(i) #> arrange, Func<<#= TypeParamList(i) #>, TResult> testFunction, Assertion assertion)
        {
            this.arrange = arrange;
            this.testFunction = testFunction;
            assertions.Add(assertion);
        }

        public static implicit operator Test(TestBuilderWithFunctionAndAssertions<<#= TypeParamList(i) #>, TResult> builder)
        {
            return new TestFunction<<#= TypeParamList(i) #>, TResult>(builder.arrange, builder.testFunction, builder.assertions);
        }

        /// <summary>
        /// Adds an additional assertion for the test.
        /// </summary>
        /// <param name="assertion">The assertion.</param>
        /// <returns>A builder for providing additional assertions for the test.</returns>
        public TestBuilderWithFunctionAndAssertions<<#= TypeParamList(i) #>, TResult> And(Expression<Action<<#= TypeParamList(i) #>, TestFunctionResult<TResult>>> assertion)
        {
            assertions.Add(new Assertion(assertion));
            return this;
        }

        /// <summary>
        /// Adds an additional assertion for the test.
        /// </summary>
        /// <param name="assertion">The assertion.</param>
        /// <param name="description">The description of the assertion.</param>
        /// <returns>A builder for providing additional assertions for the test.</returns>
        public TestBuilderWithFunctionAndAssertions<<#= TypeParamList(i) #>, TResult> And(Action<<#= TypeParamList(i) #>, TestFunctionResult<TResult>> assertion, string description)
        {
            assertions.Add(new Assertion(assertion, description));
            return this;
        }

        internal class Assertion
        {
            internal Assertion(Action<<#= TypeParamList(i) #>, TestFunctionResult<TResult>> action, string description)
            {
                Action = action;
                Description = description;
            }

            internal Assertion(Expression<Action<<#= TypeParamList(i) #>, TestFunctionResult<TResult>>> expression)
            {
                Action = expression.Compile();
                Description = expression.Body.ToString();
            }

            public Action<<#= TypeParamList(i) #>, TestFunctionResult<TResult>> Action { get; }

            public string Description { get; }
        }
    }
<# } #>
}